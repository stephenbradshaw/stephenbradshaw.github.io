---
layout: post
title: High Level Windows Shellcode Development Methods
date: '2011-04-25T00:10:00.001+10:00'
author: Stephen Bradshaw
tags:
- shellcode
modified_time: '2012-08-25T11:06:18.890+10:00'
blogger_id: tag:blogger.com,1999:blog-2318886372568084567.post-3201533017746507458
blogger_orig_url: http://www.thegreycorner.com/2011/04/high-level-windows-shellcode.html
redirect_from: /2011/04/high-level-windows-shellcode.html
---

Heres a super quick entry covering some high level methods you can use when developing Windows shellcode.<br/><br/>The methods are:<br/><ul><li>Using the memory editing features of a debugger</li><li>Using a c compiler</li><li>Using an assembler</li></ul><br/><b>Using a debugger</b><br/><br/>Writing shellcode using the code editing features of a debugger like OllyDbg is best suited to really simple (approximately &lt;20 byte) shellcode, or for making small edits to already written code while you are actually testing it.  This method is also great when you want to enter the instruction using an opcode instead of the assembly equivalent, which you may want to do when writing shellcode to work around bad character limitations.<br/><br/>The exploit writers debugger guide I wrote a while ago covers how to write and perform small edits to shellcode using the memory editing features in OllyDbg, and this should also work for Immunity Debugger.  The links are available from here:<br/><br/><a href="http://www.thegreycorner.com/2011/03/exploit-writers-debugging-tutorial.html">http://www.thegreycorner.com/2011/03/exploit-writers-debugging-tutorial.html</a><br/><br/><b>Using a c compiler</b><br/><br/>Writing shellcode using a c compiler is a good method for writing more detailed code.  Using Didier Stevens' method, you can also debug your code inside the Visual Studio IDE.  I haven't had the opportunity to use this method myself as yet, but testing this out has been on my ever expanding "To Try" list ever since I first read about it, so I thought I'd link to it here. <br/><br/>The links are available from Didier's blog, here:<br/><br/><a href="http://blog.didierstevens.com/2010/05/04/writing-win32-shellcode-with-a-c-compiler/">http://blog.didierstevens.com/2010/05/04/writing-win32-shellcode-with-a-c-compiler/</a><br/><br/><b>Using an assembler</b><br/><br/>Writing shellcode using an assembler is a fairly obvious method, and was the one I used to develop my <a href="http://grey-corner.blogspot.com/2010/05/download-and-execute-script-shellcode.html">Download and Execute Script shellcode</a>.<br/><br/>As an example of how this is done, heres some assembly code I pieced together for another Vulnserver related article I recently wrote (hopefully I'll be posting links to it here any day now).  This code is actually based on code from a SecurityForest article that is now offline, and I think they in turn got it from some older Phrack article...<br/><blockquote><span style='font-family: "Courier New",Courier,monospace;'>[BITS 32]</span><br/><br/><span style='font-family: "Courier New",Courier,monospace;'>; Shellcode to redirect execution back 768 bytes from instruction following CALL</span><br/><br/><span style='font-family: "Courier New",Courier,monospace;'>global _start</span><br/><br/><span style='font-family: "Courier New",Courier,monospace;'>jmp short jmpspot    </span><br/><span style='font-family: "Courier New",Courier,monospace;'>callspot:        ; The CALL lands here, stack now has address of next instruction</span><br/><span style='font-family: "Courier New",Courier,monospace;'>pop ecx            ; pops address of next instruction into ECX</span><br/><span style='font-family: "Courier New",Courier,monospace;'>dec ch            ; decrement CH register by 1 = ECX - 256</span><br/><span style='font-family: "Courier New",Courier,monospace;'>dec ch</span><br/><span style='font-family: "Courier New",Courier,monospace;'>dec ch</span><br/><span style='font-family: "Courier New",Courier,monospace;'>jmp ecx            ; jmp to ECX</span><br/><span style='font-family: "Courier New",Courier,monospace;'>jmpspot:</span><br/><span style='font-family: "Courier New",Courier,monospace;'>call callspot</span></blockquote><br/>Save this as shellcode.asm, then assemble to binary form into file shellcode.bin using nasm as follows:<br/><br/><blockquote style='font-family: "Courier New",Courier,monospace;'>stephen@lion:~$ nasm -f bin shellcode.asm -o shellcode.bin</blockquote><br/>We can then print this out in Hex format, ready for pasting into an exploit, using command line perl-fu<br/><br/><blockquote style='font-family: "Courier New",Courier,monospace;'>stephen@lion:~$ cat shellcode.bin | perl -e 'while (read STDIN, $d, 1) {print "\\x" . sprintf( "%02x", ord($d));}; print "\n"'<br/>\x59\xfe\xcd\xfe\xcd\xfe\xcd\xff\xe1\xe8\xf2\xff\xff\xff</blockquote><br/>Or we can get it printed out in slightly neater manner with a character count at the end using my very simple <a href="http://sites.google.com/site/lupingreycorner/convertsc2h.pl">convertsc2h.pl</a> script.<br/><br/><blockquote><span style='font-family: "Courier New",Courier,monospace;'>stephen@lion:~$ convertsc2h.pl shellcode.bin</span><br/><span style='font-family: "Courier New",Courier,monospace;'>Shellcode:</span><br/><span style='font-family: "Courier New",Courier,monospace;'>\x59\xfe\xcd\xfe\xcd\xfe\xcd\xff\xe1\xe8\xf2\xff\xff\xff</span><br/><br/><span style='font-family: "Courier New",Courier,monospace;'>Length:14</span> </blockquote>